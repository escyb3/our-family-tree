<!DOCTYPE html>
<html lang="he" dir="rtl">
<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <title>קיר זיכרון משפחתי</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- React (UMD) -->
    <script src="https://unpkg.com/react@18/umd/react.development.js" crossorigin></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.development.js" crossorigin></script>
    <!-- Babel for in-browser JSX -->
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
    <!-- Firebase SDK (Compat-style usage) -->
    <script src="https://www.gstatic.com/firebasejs/9.23.0/firebase-app-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/9.23.0/firebase-auth-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/9.23.0/firebase-firestore-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/9.23.0/firebase-storage-compat.js"></script>
    <style>
        /* small RTL-friendly font stack */
        @import url('https://fonts.googleapis.com/css2?family=Heebo:wght@300;400;700;800&display=swap');
        body { font-family: 'Heebo', system-ui, -apple-system, 'Segoe UI', Roboto, 'Helvetica Neue', Arial; }
        /* Style for the custom message modal */
        .modal-message {
          position: fixed;
          top: 20px;
          left: 50%;
          transform: translateX(-50%);
          background-color: white;
          padding: 1rem 1.5rem;
          border-radius: 0.75rem;
          box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1), 0 1px 3px rgba(0, 0, 0, 0.08);
          z-index: 1000;
          opacity: 0;
          animation: fadeInOut 4s forwards;
        }
        @keyframes fadeInOut {
          0% { opacity: 0; }
          20% { opacity: 1; }
          80% { opacity: 1; }
          100% { opacity: 0; }
        }
    </style>
</head>
<body class="bg-gray-100 text-right">
    <div id="root"></div>
    
    <script type="text/babel">
    const { useState, useEffect, useRef } = React;

    // --- i18n strings (he / en) ---
    const STRINGS = {
      he: {
        title: 'קיר זיכרון משפחתי 🕯️',
        subtitle: '"האנשים שאנו אוהבים אינם עוזבים אותנו באמת"',
        addMemory: '➕ הוסף זיכרון לקיר',
        loading: 'טוען זיכרונות...',
        lightCandle: '🕯️ הדלק נר לזכרו',
        candlesCount: (n) => `${n} נרות נשמה הודלקו`,
        commentsTitle: 'זיכרונות ותגובות',
        noComments: 'עדיין אין תגובות. היה הראשון לשתף זיכרון.',
        publishComment: 'פרסם תגובה',
        addNewMemory: 'הוסף זיכרון חדש',
        nameLabel: 'שם הנפטר/ת:',
        yearsLabel: 'שנות חיים (לדוגמה: 1943 - 2025):',
        dedicationLabel: 'הקדשה אישית (אופציונלי):',
        uploadPhoto: 'העלה תמונה (עד 5MB):',
        submitMemory: 'פרסם זיכרון',
        uploading: 'מעלה תמונה...',
        fileTooLarge: 'הקובץ גדול מדי. נא לבחור תמונה קטנה יותר (עד 5MB).',
        errorSave: 'הייתה בעיה בשמירת הזיכרון. אנא נסה שוב.',
        requiredFields: 'נא למלא את שם הנפטר/ת ושנות החיים.',
        langToggle: 'EN',
        generateDedication: '✨ צור הקדשה אוטומטית',
        generatePoem: '✨ צור שיר זיכרון',
        generating: 'יוצר...'
      },
      en: {
        title: 'Family Memorial Wall 🕯️',
        subtitle: '"The ones we love never truly leave us."',
        addMemory: '➕ Add Memorial',
        loading: 'Loading memorials...',
        lightCandle: '🕯️ Light a candle',
        candlesCount: (n) => `${n} candles lit`,
        commentsTitle: 'Memories & Comments',
        noComments: 'No comments yet. Be the first to share a memory.',
        publishComment: 'Publish Comment',
        addNewMemory: 'Add New Memorial',
        nameLabel: 'Name:',
        yearsLabel: 'Years (e.g. 1943 - 2025):',
        dedicationLabel: 'Dedication (optional):',
        uploadPhoto: 'Upload Photo (up to 5MB):',
        submitMemory: 'Publish Memorial',
        uploading: 'Uploading photo...',
        fileTooLarge: 'File too large. Choose an image under 5MB.',
        errorSave: 'There was a problem saving the memorial. Please try again.',
        requiredFields: 'Please fill in the name and years.',
        langToggle: 'עברית',
        generateDedication: '✨ Generate Dedication',
        generatePoem: '✨ Generate Poem',
        generating: 'Generating...'
      }
    };

    // Helper: get string by key
    function t(lang, key, ...args) {
      const s = STRINGS[lang][key];
      return typeof s === 'function' ? s(...args) : s;
    }

    // A simple, reusable message modal component
    function MessageModal({ message, onClose }) {
        useEffect(() => {
            const timer = setTimeout(() => {
                onClose();
            }, 3000); // Closes after 3 seconds
            return () => clearTimeout(timer);
        }, [onClose]);

        return (
            <div className="modal-message">
                <p className="text-gray-800 text-sm font-semibold">{message}</p>
            </div>
        );
    }


    // ---- MemorialCard component ----
    function MemorialCard({ memorialId, initialData, lang, currentUserId, db, storage, appId }) {
      const [memorial, setMemorial] = useState(initialData);
      const [commentText, setCommentText] = useState('');
      const [isCommentSubmitting, setIsCommentSubmitting] = useState(false);
      
      // Subscribe to this memorial doc to get real-time updates (candles, comments, etc.)
      useEffect(() => {
        if (!db) return;
        const docRef = db.collection('artifacts').doc(appId).collection('public').doc('data').collection('memorials').doc(memorialId);
        const unsubscribe = docRef.onSnapshot(docSnap => {
          if (docSnap.exists) setMemorial({ id: docSnap.id, ...docSnap.data() });
        }, err => console.error('memorial onSnapshot error', err));
        return () => unsubscribe();
      }, [memorialId, db, appId]);

      const handleLightCandle = async () => {
        try {
          const docRef = db.collection('artifacts').doc(appId).collection('public').doc('data').collection('memorials').doc(memorialId);
          // Use transaction to avoid race conditions
          await db.runTransaction(async (tx) => {
            const d = await tx.get(docRef);
            if (!d.exists) return;
            const current = d.data().candles || 0;
            tx.update(docRef, { candles: current + 1 });
          });
        } catch (err) {
          console.error('Error lighting candle', err);
        }
      };

      const handleAddComment = async (e) => {
        e && e.preventDefault();
        if (!commentText.trim()) return;
        setIsCommentSubmitting(true);
        try {
          const docRef = db.collection('artifacts').doc(appId).collection('public').doc('data').collection('memorials').doc(memorialId);
          const newComment = { author: currentUserId || 'אנונימי', text: commentText.trim(), timestamp: new Date().toLocaleString(lang === 'he' ? 'he-IL' : 'en-US') };
          // push comment atomically
          await db.runTransaction(async (tx) => {
            const d = await tx.get(docRef);
            if (!d.exists) { tx.set(docRef, { comments: [newComment] }, { merge: true }); return; }
            const existing = d.data().comments || [];
            tx.update(docRef, { comments: [...existing, newComment] });
          });
          setCommentText('');
        } catch (err) {
          console.error('Error adding comment', err);
        } finally {
          setIsCommentSubmitting(false);
        }
      };

      return (
        <div className="bg-white rounded-xl shadow-lg p-6 flex flex-col items-center max-w-lg mx-auto transition-transform duration-300 hover:scale-105">
          <img src={memorial.photoUrl} alt={memorial.name} className="w-32 h-32 rounded-full object-cover mb-4 border-4 border-gray-200" />
          <h3 className="text-2xl font-bold text-gray-800 mb-1">{memorial.name}</h3>
          <p className="text-gray-500 italic mb-2">{memorial.years}</p>
          <p className="text-gray-600 text-center mb-4">{memorial.dedication}</p>

          <div className="flex items-center gap-4 mt-4">
            <button onClick={handleLightCandle} className="bg-red-600 text-white font-bold py-2 px-4 rounded-full shadow-md hover:bg-red-700 transition">{t(lang,'lightCandle')}</button>
            <span className="text-gray-700 font-medium">{t(lang,'candlesCount', memorial.candles || 0)}</span>
          </div>

          <div className="w-full mt-6">
            <h4 className="text-xl font-bold mb-4 border-b pb-2 border-gray-200">{t(lang,'commentsTitle')}</h4>
            <ul className="space-y-3 max-h-48 overflow-y-auto pr-2">
              {(memorial.comments && memorial.comments.length > 0) ? (
                memorial.comments.map((c, i) => (
                  <li key={i} className="bg-gray-50 p-3 rounded-lg shadow-sm">
                    <p className="text-gray-800 text-sm">{c.text}</p>
                    <div className="text-gray-400 text-xs mt-1">
                      <span>מאת: {c.author}</span>
                      <span className="mr-2"> | {c.timestamp}</span>
                    </div>
                  </li>
                ))
              ) : (
                <p className="text-gray-500 text-center text-sm">{t(lang,'noComments')}</p>
              )}
            </ul>

            <form onSubmit={handleAddComment} className="mt-3 flex flex-col gap-2">
              <textarea value={commentText} onChange={e=>setCommentText(e.target.value)} placeholder={t(lang,'noComments')} className="w-full p-3 rounded-lg border border-gray-300 focus:outline-none focus:ring-2 focus:ring-blue-500 text-right" rows="3" dir={lang==='he'?'rtl':'ltr'}></textarea>
              <div className="flex gap-2 justify-end">
                <button type="submit" disabled={isCommentSubmitting} className="bg-blue-500 text-white font-bold py-2 px-4 rounded-lg hover:bg-blue-600 transition">{isCommentSubmitting ? t(lang,'uploading') : t(lang,'publishComment')}</button>
              </div>
            </form>
          </div>
        </div>
      );
    }

    // ---- Main App ----
    function App() {
      const [lang, setLang] = useState('he');
      const [memorials, setMemorials] = useState([]);
      const [isModalOpen, setIsModalOpen] = useState(false);
      const [newMemorial, setNewMemorial] = useState({ name: '', years: '', dedication: '', photoFile: null });
      const [isLoading, setIsLoading] = useState(true);
      const [isUploading, setIsUploading] = useState(false);
      const [isGenerating, setIsGenerating] = useState(false);
      const [userId, setUserId] = useState(null);
      const [message, setMessage] = useState(null);

      // Firebase instances
      const [db, setDb] = useState(null);
      const [storage, setStorage] = useState(null);
      const [appId, setAppId] = useState(null);
      
      // Initialize Firebase on component mount
      useEffect(() => {
        try {
            // Use global variables if available, otherwise use a placeholder
            const firebaseConfig = typeof __firebase_config !== 'undefined' ? JSON.parse(__firebase_config) : {
              apiKey: "AIzaSyB6CtzBQMV9JXJSgL1gxKjdB2kP5UQ_63E",
              authDomain: "memorials-4f3f8.firebaseapp.com",
              projectId: "memorials-4f3f8",
              storageBucket: "memorials-4f3f8.firebasestorage.app",
              messagingSenderId: "456197169350",
              appId: "1:456197169350:web:7b5e0f161fdc8d3e9eb7c7",
              measurementId: "G-F1XVYMY9BE"
            };
            const appId = typeof __app_id !== 'undefined' ? __app_id : 'default-app-id';
            const initialAuthToken = typeof __initial_auth_token !== 'undefined' ? __initial_auth_token : null;

            // Initialize Firebase services
            const app = firebase.initializeApp(firebaseConfig);
            const auth = app.auth();
            const dbInstance = app.firestore();
            const storageInstance = app.storage();
            
            setDb(dbInstance);
            setStorage(storageInstance);
            setAppId(appId);

            // Authenticate the user
            (async () => {
                try {
                    if (initialAuthToken) {
                        await auth.signInWithCustomToken(initialAuthToken);
                    } else {
                        await auth.signInAnonymously();
                    }
                } catch (err) {
                    console.error('Auth error', err);
                }
            })();

            // Listen for auth state changes to get the user ID
            const unsubscribeAuth = auth.onAuthStateChanged(user => {
                if (user) {
                    setUserId(user.uid);
                    
                    const memorialsCollection = dbInstance.collection('artifacts').doc(appId).collection('public').doc('data').collection('memorials');
                    
                    const initialSeed = [
                        {
                            id: 'frank-van-der-velde',
                            name: 'פרנק ון דר ולדה',
                            years: '1943 - 2025',
                            dedication: 'פרנק היה אדם אהוב, אבא, סבא, חבר, ונשמה חמה וטובה.',
                            photoUrl: 'https://placehold.co/150x150/E9D5FF/5B21B6?text=פרנק',
                            candles: 0,
                            comments: []
                        }
                    ];

                    // Seed docs if they don't exist
                    (async () => {
                        for (const s of initialSeed) {
                            const docRef = memorialsCollection.doc(s.id);
                            const snap = await docRef.get();
                            if (!snap.exists) await docRef.set(s);
                        }
                    })();

                    // Listen for real-time changes to the memorials collection
                    const unsubscribeSnapshot = memorialsCollection.onSnapshot(snapshot => {
                        const arr = snapshot.docs.map(d => ({ id: d.id, ...d.data() }));
                        arr.sort((a,b)=> (a.name||'').localeCompare(b.name||'', lang));
                        setMemorials(arr);
                        setIsLoading(false);
                    }, err => { 
                        console.error('Collection onSnapshot error', err);
                        setIsLoading(false); 
                    });

                    // Cleanup function
                    return () => unsubscribeSnapshot();
                } else {
                    setUserId(null);
                }
            });

            // Final cleanup
            return () => unsubscribeAuth();

        } catch (err) {
            console.error("Firebase initialization failed:", err);
            setIsLoading(false);
        }
      }, [lang]);

      const handleInputChange = (e) => {
        const { id, value } = e.target;
        setNewMemorial(prev => ({ ...prev, [id]: value }));
      };

      const handleFileChange = (e) => {
        const file = e.target.files[0];
        if (!file) return;
        // 5MB file size limit
        if (file.size > 5 * 1024 * 1024) {
          setMessage(t(lang, 'fileTooLarge'));
          e.target.value = '';
          return;
        }
        setNewMemorial(prev => ({ ...prev, photoFile: file }));
      };

      const handleAddMemorial = async (e) => {
        e.preventDefault();
        if (!newMemorial.name || !newMemorial.years) {
          setMessage(t(lang, 'requiredFields'));
          return;
        }
        setIsUploading(true);
        try {
          let photoUrl = `https://placehold.co/150x150/E2E8F0/1A202C?text=${encodeURIComponent(newMemorial.name.charAt(0) || 'M')}`;
          if (newMemorial.photoFile) {
            const storageRef = storage.ref(`memorial-photos/${appId}/${Date.now()}-${newMemorial.photoFile.name}`);
            const snapshot = await storageRef.put(newMemorial.photoFile);
            photoUrl = await snapshot.ref.getDownloadURL();
          }
          const memorialData = { name: newMemorial.name, years: newMemorial.years, dedication: newMemorial.dedication || '', candles: 0, comments: [], photoUrl };
          await db.collection('artifacts').doc(appId).collection('public').doc('data').collection('memorials').add(memorialData);
          setNewMemorial({ name: '', years: '', dedication: '', photoFile: null });
          setIsModalOpen(false);
        } catch (err) {
          console.error(err);
          setMessage(t(lang, 'errorSave'));
        } finally {
          setIsUploading(false);
        }
      };

      // --- Gemini API integrations ---

      // פונקציה ליצירת הקדשה אוטומטית באמצעות Gemini
      const handleGenerateDedication = async () => {
        if (!newMemorial.name) {
          setMessage(t(lang, 'requiredFields'));
          return;
        }
        setIsGenerating(true);
        const prompt = `כתוב הקדשה קצרה ומרגשת לזכר אדם שנפטר. שם הנפטר הוא "${newMemorial.name}". השתמש בטון מכובד ומנחם. ההקדשה צריכה להיות לא יותר מ-30 מילים.`;
        try {
          // fetch call to the Gemini API with exponential backoff
          let chatHistory = [];
          chatHistory.push({ role: "user", parts: [{ text: prompt }] });
          const payload = { contents: chatHistory };
          const apiKey = "" 
          const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-preview-05-20:generateContent?key=${apiKey}`;
          let response;
          for (let i = 0; i < 3; i++) {
              try {
                  response = await fetch(apiUrl, {
                      method: 'POST',
                      headers: { 'Content-Type': 'application/json' },
                      body: JSON.stringify(payload)
                  });
                  if (response.status !== 429) {
                      break;
                  }
                  await new Promise(resolve => setTimeout(resolve, Math.pow(2, i) * 1000));
              } catch (e) {
                  await new Promise(resolve => setTimeout(resolve, Math.pow(2, i) * 1000));
              }
          }
          const result = await response.json();
          const generatedText = result?.candidates?.[0]?.content?.parts?.[0]?.text;
          if (generatedText) {
            setNewMemorial(prev => ({ ...prev, dedication: generatedText.trim() }));
          }
        } catch (err) {
          console.error('Error generating dedication', err);
          setMessage("הייתה בעיה ביצירת ההקדשה. אנא נסה שוב.");
        } finally {
          setIsGenerating(false);
        }
      };

      // פונקציה ליצירת שיר זיכרון קצר באמצעות Gemini
      const handleGeneratePoem = async () => {
        if (!newMemorial.name) {
          setMessage(t(lang, 'requiredFields'));
          return;
        }
        setIsGenerating(true);
        const prompt = `כתוב שיר זיכרון קצר על אדם אהוב שנפטר. שם הנפטר/ת: "${newMemorial.name}". התמקד בזיכרון, אהבה, וגעגוע. השיר צריך להיות בעל 4-6 שורות.`;
        try {
            // fetch call to the Gemini API with exponential backoff
            let chatHistory = [];
            chatHistory.push({ role: "user", parts: [{ text: prompt }] });
            const payload = { contents: chatHistory };
            const apiKey = "" 
            const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-preview-05-20:generateContent?key=${apiKey}`;
            let response;
            for (let i = 0; i < 3; i++) {
                try {
                    response = await fetch(apiUrl, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify(payload)
                    });
                    if (response.status !== 429) {
                        break;
                    }
                    await new Promise(resolve => setTimeout(resolve, Math.pow(2, i) * 1000));
                } catch (e) {
                    await new Promise(resolve => setTimeout(resolve, Math.pow(2, i) * 1000));
                }
            }
            const result = await response.json();
            const generatedText = result?.candidates?.[0]?.content?.parts?.[0]?.text;
            if (generatedText) {
                setNewMemorial(prev => ({ ...prev, dedication: generatedText.trim() }));
            }
        } catch (err) {
          console.error('Error generating poem', err);
          setMessage("הייתה בעיה ביצירת השיר. אנא נסה שוב.");
        } finally {
          setIsGenerating(false);
        }
      };

      return (
        <div className="min-h-screen p-6">
          <div className="max-w-5xl mx-auto">
            <div className="flex justify-between items-center mb-8">
              <div>
                <h1 className="text-4xl font-bold text-gray-800">{t(lang,'title')}</h1>
                <p className="text-gray-600 mt-1">{t(lang,'subtitle')}</p>
              </div>
              <div className="flex items-center gap-2">
                <button onClick={()=>setLang(l=> l==='he'?'en':'he')} className="border px-3 py-2 rounded-md">{t(lang,'langToggle')}</button>
                <button onClick={()=>setIsModalOpen(true)} className="bg-blue-500 text-white font-bold py-2 px-4 rounded-lg shadow-md hover:bg-blue-600 transition">{t(lang,'addMemory')}</button>
              </div>
            </div>

            {isLoading ? (<p className="text-center text-gray-500">{t(lang,'loading')}</p>) : (
              <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-6">
                {memorials.map(m => (
                  <MemorialCard key={m.id} memorialId={m.id} initialData={m} lang={lang} currentUserId={userId} db={db} storage={storage} appId={appId}/>
                ))}
              </div>
            )}
          </div>

          {/* Modal for adding a new memorial */}
          {isModalOpen && (
            <div className="fixed inset-0 bg-black bg-opacity-50 flex justify-center items-center p-4">
              <div className="bg-white rounded-xl shadow-2xl p-6 w-full max-w-md relative">
                <button onClick={()=>setIsModalOpen(false)} className="absolute top-3 left-3 text-gray-500 text-2xl">&times;</button>
                <h2 className="text-2xl font-bold mb-4 text-center">{t(lang,'addNewMemory')}</h2>
                <form onSubmit={handleAddMemorial} className="space-y-3 text-right">
                  <div>
                    <label htmlFor="name" className="block text-gray-700 mb-1">{t(lang,'nameLabel')}</label>
                    <input id="name" value={newMemorial.name} onChange={handleInputChange} className="w-full p-3 rounded-lg border" dir={lang==='he'?'rtl':'ltr'} required />
                  </div>
                  <div>
                    <label htmlFor="years" className="block text-gray-700 mb-1">{t(lang,'yearsLabel')}</label>
                    <input id="years" value={newMemorial.years} onChange={handleInputChange} className="w-full p-3 rounded-lg border" dir={lang==='he'?'rtl':'ltr'} required />
                  </div>
                  <div>
                    <label htmlFor="dedication" className="block text-gray-700 mb-1">{t(lang,'dedicationLabel')}</label>
                    <textarea id="dedication" value={newMemorial.dedication} onChange={handleInputChange} className="w-full p-3 rounded-lg border" rows="3" dir={lang==='he'?'rtl':'ltr'}></textarea>
                    {/* Gemini API Buttons */}
                    <div className="flex gap-2 mt-2">
                      <button type="button" onClick={handleGenerateDedication} disabled={isGenerating || !newMemorial.name} className="flex-1 bg-green-500 text-white font-bold py-2 px-4 rounded-lg hover:bg-green-600 transition disabled:bg-gray-400 disabled:cursor-not-allowed">
                        {isGenerating ? t(lang, 'generating') : t(lang, 'generateDedication')}
                      </button>
                      <button type="button" onClick={handleGeneratePoem} disabled={isGenerating || !newMemorial.name} className="flex-1 bg-purple-500 text-white font-bold py-2 px-4 rounded-lg hover:bg-purple-600 transition disabled:bg-gray-400 disabled:cursor-not-allowed">
                        {isGenerating ? t(lang, 'generating') : t(lang, 'generatePoem')}
                      </button>
                    </div>
                  </div>
                  <div>
                    <label htmlFor="photoFile" className="block text-gray-700 mb-1">{t(lang,'uploadPhoto')}</label>
                    <input id="photoFile" type="file" accept="image/*" onChange={handleFileChange} className="w-full" />
                  </div>
                  <button type="submit" disabled={isUploading} className="w-full bg-blue-500 text-white py-3 rounded-lg font-bold">{isUploading? t(lang,'uploading') : t(lang,'submitMemory')}</button>
                </form>
              </div>
            </div>
          )}
          
          {/* Message modal */}
          {message && <MessageModal message={message} onClose={() => setMessage(null)} />}
        </div>
      );
    }

    // Render the app
    ReactDOM.createRoot(document.getElementById('root')).render(<App />);

    </script>
</body>
</html>

