<!DOCTYPE html><html lang="he" dir="rtl"><head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>מערכת דוא"ל פנימית</title>
     <!-- Font Awesome for icons -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0-beta3/css/all.min.css">
    <!-- Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Heebo:wght@400;500;700&display=swap');
        body {
            font-family: 'Heebo', sans-serif;
            direction: rtl; /* Set default direction to RTL for Hebrew */
        }
        /* Custom scrollbar */
        ::-webkit-scrollbar {
            width: 8px;
        }
        ::-webkit-scrollbar-track {
            background: #f1f1f1;
        }
        ::-webkit-scrollbar-thumb {
            background: #cbd5e1;
            border-radius: 4px;
        }
        ::-webkit-scrollbar-thumb:hover {
            background: #94a3b8;
        }
        .checkmark {
            color: #10B981; /* Green color for the checkmark */
        }
        .email-item {
            border-right: 4px solid transparent;
            transition: background-color 0.1s;
        }
        .email-item:hover {
            background-color: #f7fafc;
        }
        .email-item.unread {
            font-weight: 700;
            border-right: 4px solid #3b82f6; /* Blue border for unread in RTL */
        }
        .active-folder {
            background-color: #dbeafe !important;
            color: #1e40af !important;
            font-weight: 600;
        }
    </style>
</head>
<body class="bg-gray-100">
  <!-- Modals for confirmation messages (replacing alert/confirm) -->
  <div id="modalOverlay" class="fixed inset-0 bg-black bg-opacity-50 hidden items-center justify-center z-50">
      <div id="modalContent" class="bg-white p-6 rounded-xl shadow-2xl w-full max-w-sm text-center">
          <p id="modalMessage" class="text-lg font-medium mb-4">הודעה</p>
          <div id="modalButtons" class="flex justify-center space-x-4 space-x-reverse">
              <button id="modalConfirmBtn" class="bg-red-500 text-white px-4 py-2 rounded hover:bg-red-600 transition">אישור</button>
              <button id="modalCancelBtn" class="bg-gray-300 px-4 py-2 rounded hover:bg-gray-400 transition">ביטול</button>
          </div>
      </div>
  </div>
    
  <div id="loadingPage" class="flex h-screen items-center justify-center">
    <div class="bg-white p-6 rounded-xl shadow-md text-center">
      <h1 class="text-2xl font-bold" id="loadingText">מאחזר זהות משתמש...</h1>
      <p id="loadingSubtext">מתחבר לשרת לאימות...</p>
    </div>
  </div>

  <div id="appPage" class="hidden h-screen flex">
    <aside class="w-64 bg-white p-4 shadow-md flex flex-col">
      <div class="flex justify-between items-center mb-4">
        <h2 class="text-xl font-bold" id="mailboxTitle">תיבת דואר</h2>
        <button id="langToggle" class="bg-gray-200 text-sm px-2 py-1 rounded">EN</button>
      </div>
      <div class="flex items-center mb-4 border-b pb-4">
        <span class="text-green-600 font-bold">✔</span>
        <p id="userEmailDisplay" class="ml-2 text-gray-700 text-sm"></p>
      </div>
      <button id="newEmailButton" class="bg-blue-500 text-white px-4 py-3 rounded-xl mb-4 text-lg font-semibold hover:bg-blue-600 transition shadow-md">הודעה חדשה</button>
      
      <!-- Folder buttons -->
      <nav>
          <button data-folder="inbox" class="folder-btn w-full bg-blue-100 text-blue-800 px-3 py-2 rounded-lg mb-1 text-right active-folder flex items-center">
              <i class="fas fa-inbox ml-2"></i> <span id="inboxBtn">נכנס</span>
          </button>
          <button data-folder="sent" class="folder-btn w-full px-3 py-2 rounded-lg mb-1 text-right hover:bg-gray-100 flex items-center">
              <i class="fas fa-paper-plane ml-2"></i> <span id="sentBtn">נשלח</span>
          </button>
          <button data-folder="drafts" class="folder-btn w-full px-3 py-2 rounded-lg mb-1 text-right hover:bg-gray-100 flex items-center">
              <i class="fas fa-file-alt ml-2"></i> <span id="draftsBtn">טיוטות</span>
          </button>
          <button data-folder="trash" class="folder-btn w-full px-3 py-2 rounded-lg mb-1 text-right hover:bg-gray-100 flex items-center">
              <i class="fas fa-trash ml-2"></i> <span id="trashBtn">זבל</span>
          </button>
      </nav>
      
      <div class="mt-4 text-sm text-gray-600 overflow-y-auto flex-grow">
          <h4 class="font-bold mb-2 border-b pb-1 hidden" id="draftsHeader">טיוטות</h4>
          <ul id="draftsList"></ul>
      </div>
    </aside>

    <main class="flex-1 p-6 flex flex-col">
      <!-- Container for the list of emails in the currently selected folder -->
      <div id="emailList" class="overflow-y-auto mb-4 border rounded-xl bg-white shadow-lg flex-grow">
          <!-- Emails will be rendered here -->
      </div>
      
      <div id="emptyState" class="text-center text-gray-500 hidden mt-10">
        בחר אימייל לצפייה או צור הודעה חדשה.
      </div>
      
      <div id="emailView" class="hidden p-6 border rounded-xl bg-white shadow-lg flex-grow">
          <!-- Single email content view here -->
      </div>

      <div id="composeView" class="hidden p-6 border rounded-xl bg-white shadow-lg flex-grow flex flex-col">
        <h3 class="text-2xl font-bold mb-4 text-indigo-700" id="newMessageTitle">הודעה חדשה</h3>
        <input id="composeTo" placeholder="אל (הקלד שם משתמש)" class="w-full border p-3 mb-3 rounded-lg focus:ring-blue-500 focus:border-blue-500 transition" />
        <input id="composeSubject" placeholder="נושא" class="w-full border p-3 mb-3 rounded-lg focus:ring-blue-500 focus:border-blue-500 transition" />
        <textarea id="composeBody" placeholder="תוכן" class="w-full border p-3 mb-4 rounded-lg h-full flex-grow resize-none focus:ring-blue-500 focus:border-blue-500 transition"></textarea>
        <div class="flex space-x-2 space-x-reverse mt-2">
          <button id="sendButton" class="bg-green-500 text-white px-6 py-3 rounded-lg hover:bg-green-600 transition font-semibold">שלח</button>
          <button id="saveDraftButton" class="bg-yellow-500 text-white px-6 py-3 rounded-lg hover:bg-yellow-600 transition font-semibold">שמור טיוטה</button>
          <button id="cancelButton" class="bg-gray-300 px-6 py-3 rounded-lg hover:bg-gray-400 transition font-semibold">בטל</button>
          <button id="translateButton" class="bg-purple-500 text-white px-6 py-3 rounded-lg hover:bg-purple-600 transition font-semibold">תרגם</button>
        </div>
      </div>
    </main>
  </div>

  <script type="module">
    // --- FIREBASE IMPORTS (v11.6.1) ---
    // Note: Firebase Auth functions are imported but will *not* be used for login/session management, 
    // honoring the constraint that identity comes solely from the server API.
    import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
    import { getAuth } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
    import { getFirestore, collection, addDoc, setDoc, deleteDoc, doc, onSnapshot, Timestamp, query, where, updateDoc } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";
    
    // --- CANVAS MANDATORY GLOBAL VARIABLES ---
    const appId = typeof __app_id !== 'undefined' ? __app_id : 'default-app-id';
             const firebaseConfig = {
      apiKey: "AIzaSyAID_kPGA6Khczh0lIgd7E13LJS76JJ9nI",
      authDomain: "mailbox-e0ce2.firebaseapp.com",
      projectId: "mailbox-e0ce2",
      storageBucket: "mailbox-e0ce2.appspot.com",
      messagingSenderId: "199399854104",
      appId: "1:199399854104:web:6aec488e6aeee0dec3736d"
    };
    // The auth token is ignored as per the user's constraint to rely only on /api/user.
    // const initialAuthToken = typeof __initial_auth_token !== 'undefined' ? __initial_auth_token : null; 

    // Initialize Firebase services (Firestore is required)
    const app = initializeApp(firebaseConfig);
    const db = getFirestore(app);
    // Auth is initialized but not used for login/session management
    const auth = getAuth(app); 

    // --- UI ELEMENTS ---
    const loadingPage = document.getElementById("loadingPage");
    const appPage = document.getElementById("appPage");
    const userEmailDisplay = document.getElementById("userEmailDisplay");
    const newEmailButton = document.getElementById("newEmailButton");
    const composeView = document.getElementById("composeView");
    const emptyState = document.getElementById("emptyState");
    const emailList = document.getElementById("emailList");
    const emailView = document.getElementById("emailView");
    const sendButton = document.getElementById("sendButton");
    const saveDraftButton = document.getElementById("saveDraftButton");
    const cancelButton = document.getElementById("cancelButton");
    const translateButton = document.getElementById("translateButton");
    const composeTo = document.getElementById("composeTo");
    const composeSubject = document.getElementById("composeSubject");
    const composeBody = document.getElementById("composeBody");
    const draftsList = document.getElementById("draftsList");
    const draftsHeader = document.getElementById("draftsHeader");
    const folderButtons = document.querySelectorAll('.folder-btn');
    
    // Modal Elements
    const modalOverlay = document.getElementById("modalOverlay");
    const modalMessage = document.getElementById("modalMessage");
    const modalConfirmBtn = document.getElementById("modalConfirmBtn");
    const modalCancelBtn = document.getElementById("modalCancelBtn");
    
    // --- TRANSLATIONS ---
    const translations = {
      he: {
        mailboxTitle: "תיבת דואר", newEmail: "הודעה חדשה", inbox: "נכנס", sent: "נשלח", drafts: "טיוטות", trash: "זבל",
        emptyState: "בחר אימייל לצפייה או צור הודעה חדשה.", newMessageTitle: "הודעה חדשה", send: "שלח", saveDraft: "שמור טיוטה",
        cancel: "בטל", translate: "תרגם", noSubject: "(ללא נושא)", to: "אל", from: "מאת", noEmails: "תיקייה זו ריקה.",
        deleteDraftConfirm: "האם למחוק טיוטה זו?", errorLogin: "שגיאת התחברות: לא ניתן לאחזר זהות משתמש מהשרת.", errorTitle: "שגיאת כניסה",
        errorEmailFetch: "שגיאה: השרת החזיר נתונים חסרים (אימייל או UID).", errorFetchStatus: "שגיאת שרת או אימות: לא ניתן לאחזר פרטי משתמש.",
        errorAnon: "נדרשת התחברות מאומתת (לא אנונימית).", validatingID: "מאחזר זהות משתמש..."
      },
      en: {
        mailboxTitle: "Mailbox", newEmail: "New Message", inbox: "Inbox", sent: "Sent", drafts: "Drafts", trash: "Trash",
        emptyState: "Select an email to view or create a new one.", newMessageTitle: "New Message", send: "Send", saveDraft: "Save Draft",
        cancel: "Cancel", translate: "Translate", noSubject: "(No Subject)", to: "To", "from": "From", noEmails: "This folder is empty.",
        deleteDraftConfirm: "Delete this draft?", errorLogin: "Login Error: Could not retrieve user identity from server.", errorTitle: "Login Error",
        errorEmailFetch: "Error: Server returned missing data (email or UID).", errorFetchStatus: "Server or authentication error: Could not fetch user details.",
        errorAnon: "Requires validated (non-anonymous) login.", validatingID: "Fetching user identity..."
      }
    };
    
    let currentLang = "he";
    
    // --- STATE MANAGEMENT ---
    const state = {
      db: db,
      auth: auth, // Keep for initialization but not for login
      userId: null, // Server-derived UID (used for private Firestore paths)
      isAuthReady: false,
      emailAddress: null, // Canonical email (user@family.local)
      inboxEmails: [], 
      sentEmails: [],  
      currentFolder: "inbox",
      editingDraftId: null
    };
    
    // --- UTILITIES ---

    // Function to handle custom confirmation modal
    function showConfirmation(message, onConfirm) {
        modalMessage.textContent = message;
        modalOverlay.classList.remove("hidden");
        modalOverlay.classList.add("flex");
        
        modalConfirmBtn.textContent = translations[currentLang].send; // Use 'Send' or 'Yes' equivalent
        modalCancelBtn.textContent = translations[currentLang].cancel;
        
        // Reset listeners
        modalConfirmBtn.onclick = null;
        modalCancelBtn.onclick = null;

        modalConfirmBtn.onclick = () => {
            modalOverlay.classList.add("hidden");
            modalOverlay.classList.remove("flex");
            onConfirm();
        };

        modalCancelBtn.onclick = () => {
            modalOverlay.classList.add("hidden");
            modalOverlay.classList.remove("flex");
        };
    }
    
    function applyTranslations() {
      const t = translations[currentLang];
      document.documentElement.dir = currentLang === "he" ? "rtl" : "ltr";
      document.getElementById("mailboxTitle").textContent = t.mailboxTitle;
      newEmailButton.textContent = t.newEmail;
      
      document.getElementById('inboxBtn').textContent = t.inbox;
      document.getElementById('sentBtn').textContent = t.sent;
      document.getElementById('draftsBtn').textContent = t.drafts;
      document.getElementById('trashBtn').textContent = t.trash;

      emptyState.textContent = t.emptyState;
      document.getElementById("newMessageTitle").textContent = t.newMessageTitle;
      sendButton.textContent = t.send;
      saveDraftButton.textContent = t.saveDraft;
      cancelButton.textContent = t.cancel;
      translateButton.textContent = t.translate;
      
      document.getElementById("loadingText").textContent = t.validatingID;
      document.getElementById("loadingSubtext").textContent = currentLang === "he" ? "מתחבר לשרת לאימות..." : "Connecting to server for validation...";
      langToggle.textContent = currentLang === "he" ? "EN" : "HE";
      composeTo.placeholder = currentLang === "he" ? "אל (הקלד שם משתמש)" : "To (Enter username)";

      if (state.isAuthReady) {
        showFolder(state.currentFolder);
        listenToDrafts();
        userEmailDisplay.textContent = `${currentLang === 'he' ? 'מחובר כ- ' : 'Logged in as '} ${state.emailAddress} (ID: ${state.userId})`;
      }
    }

    langToggle.addEventListener("click", () => {
      currentLang = currentLang === "he" ? "en" : "he";
      applyTranslations();
    });
    
    function showLoginError(message) {
         const t = translations[currentLang];
         document.getElementById("loadingText").textContent = t.errorTitle;
         document.getElementById("loadingSubtext").textContent = message;
         loadingPage.classList.remove("hidden");
         appPage.classList.add("hidden");
         console.error(`[FATAL ERROR] Displaying: ${message}`);
    }

    /**
     * Helper function to perform fetch requests with exponential backoff and retry.
     */
    async function fetchWithRetry(url, options, maxRetries = 3) {
        for (let i = 0; i < maxRetries; i++) {
            try {
                const response = await fetch(url, options);
                if (!response.ok) {
                    throw new Error(`HTTP error! Status: ${response.status}`);
                }
                return response;
            } catch (error) {
                if (i === maxRetries - 1) {
                    throw error;
                }
                // Exponential backoff: 1s, 2s, 4s...
                const delay = Math.pow(2, i) * 1000;
                // console.log(`[Fetch Retry] Retrying ${url} in ${delay / 1000}s...`);
                await new Promise(resolve => setTimeout(resolve, delay));
            }
        }
    }
    
    // --- API CALL: Fetches REAL user identity from the server (MANDATORY) ---
    async function fetchUserDetails() {
        const t = translations[currentLang];
        
        // This is the required endpoint to get the user's canonical identity.
        const apiUrl = '/api/user'; 
        
        console.log(`[API CALL: ${apiUrl}] Attempting to retrieve canonical user identity.`);
        
        document.getElementById("loadingText").textContent = t.validatingID;
        
        let response;
        try {
            // Using fetchWithRetry for robustness
            response = await fetchWithRetry(apiUrl, { 
                method: 'GET',
            }, 3);
            
            const userData = await response.json();
            
            // --- FIX: Accessing the nested 'user' object from the server response ---
            const userDetails = userData.user;
            
            // Expected structure: { user: { uid: "server_id_1234", email: "user@family.local" } }
            if (!userData || !userDetails || !userDetails.uid || !userDetails.email) {
                throw new Error(t.errorEmailFetch); 
            }

            // Ensure the email adheres to the internal family format (for warning)
            if (!userDetails.email.endsWith('@family.local') && userDetails.email !== "לא מוגדר") {
                console.warn("API returned non-family email address or 'לא מוגדר':", userDetails.email);
            }

            console.log(`[API SUCCESS] Canonical App Email: ${userDetails.email} (App ID: ${userDetails.uid})`);
            
            return {
                uid: userDetails.uid,     // Server-validated ID (Used for private Firestore paths)
                email: userDetails.email  // Server-validated Email (Used for public query identity)
            };

        } catch (error) {
            console.error(`Error fetching user details from ${apiUrl}:`, error);
            // Re-throw standardized error message for display
            throw new Error(error.message.includes("missing data") ? t.errorEmailFetch : t.errorFetchStatus);
        }
    }

    // --- APPLICATION STARTUP (Identity first, then connect to Firestore) ---
    async function initializeApplication() {
        const t = translations[currentLang];
        
        document.getElementById("loadingText").textContent = t.validatingID;

        try {
            // STEP 1: Fetch the REAL user identity (UID and Email) from the server API
            const userData = await fetchUserDetails(); 
            
            // Set state based on API response (The user's identity in the app)
            state.userId = userData.uid; // Server-validated ID (Used for private path security)
            state.emailAddress = userData.email; // Server-validated Email (Used for public query identity)
            
            // Check for the "לא מוגדר" safety value and treat it as a failure to authenticate validly
            if (state.emailAddress === "לא מוגדר" || state.userId === "לא מוגדר") {
                throw new Error(t.errorEmailFetch); 
            }

            // 2. Successful initialization
            userEmailDisplay.textContent = `${currentLang === 'he' ? 'מחובר כ- ' : 'Logged in as '} ${state.emailAddress} (ID: ${state.userId})`;
            state.isAuthReady = true;
            loadingPage.classList.add("hidden");
            appPage.classList.remove("hidden");
            
            // Start listeners and render UI
            listenToEmails(); // Uses state.emailAddress (public/shared)
            listenToDrafts(); // Uses state.userId (private)
            showFolder("inbox");
            applyTranslations();
            
        } catch (e) {
             // Catch error from fetchUserDetails (API failed/missing data)
             console.error("Authentication/API identity retrieval failed:", e);
             showLoginError(e.message || t.errorLogin); 
        }
    }

    // Start the application flow
    initializeApplication();
    

    // --- FOLDER MANAGEMENT AND RENDERING (Minimal changes to use state.userId) ---
    folderButtons.forEach(btn => {
        btn.addEventListener('click', () => {
            showFolder(btn.getAttribute('data-folder'));
        });
    });

    function showFolder(folder) {
        state.currentFolder = folder;
        const t = translations[currentLang];

        // 1. Update active class on buttons
        folderButtons.forEach(btn => {
            btn.classList.remove('active-folder', 'bg-blue-100', 'text-blue-800');
            btn.classList.add('hover:bg-gray-100');
        });
        document.querySelector(`[data-folder="${folder}"]`).classList.add('active-folder', 'bg-blue-100', 'text-blue-800');
        document.querySelector(`[data-folder="${folder}"]`).classList.remove('hover:bg-gray-100');

        // 2. Hide compose/view, show list container
        composeView.classList.add("hidden");
        emailView.classList.add("hidden");
        emailList.classList.remove("hidden");
        emptyState.classList.add("hidden");
        
        // 3. Determine which list to display
        draftsList.parentElement.classList.remove('flex-grow'); // Hide drafts header container
        emailList.innerHTML = ''; // Clear main list container
        
        let emailsToDisplay = [];

        if (folder === 'inbox') {
            emailsToDisplay = state.inboxEmails;
        } else if (folder === 'sent') {
            emailsToDisplay = state.sentEmails;
        } else if (folder === 'drafts') {
            emailList.classList.add("hidden");
            // Show drafts list container if there are drafts
            if (draftsList.children.length === 0) {
                 draftsHeader.classList.add("hidden");
                 emptyState.textContent = t.noEmails;
                 emptyState.classList.remove("hidden");
            } else {
                 draftsHeader.classList.remove("hidden");
                 emptyState.classList.add("hidden");
            }
            return; // Skip main emailList rendering
        } else if (folder === 'trash') {
             // Not implemented yet, show empty state
             emptyState.textContent = t.noEmails;
             emptyState.classList.remove("hidden");
             return;
        }

        renderEmailList(emailsToDisplay);
    }

    function renderEmailList(emailsToDisplay) {
        const t = translations[currentLang];
        emailList.innerHTML = '';

        if (emailsToDisplay.length === 0) {
            emailList.innerHTML = `<div class="p-4 text-center text-gray-400">${t.noEmails}</div>`;
            return;
        }
        
        // Sort by timestamp descending (in memory, as required)
        emailsToDisplay.sort((a, b) => b.timestamp.toMillis() - a.timestamp.toMillis());

        emailsToDisplay.forEach(email => {
            const isInbox = email.folder === 'inbox';
            const senderOrRecipient = isInbox ? email.sender : email.recipient;
            const subject = email.subject || t.noSubject;
            
            const item = document.createElement("div");
            item.classList.add("email-item", "p-3", "border-b", "cursor-pointer", "text-sm", "flex", "justify-between", "items-center");
            
            if (isInbox && !email.read) {
                item.classList.add("unread");
            }
            
            item.setAttribute('data-id', email.id);
            item.setAttribute('data-folder', email.folder);

            const content = document.createElement("div");
            content.classList.add("flex-1", "min-w-0");
            
            const header = document.createElement("div");
            header.classList.add("flex", "justify-between", "items-center", "mb-1");
            header.innerHTML = `
                <span class="truncate font-medium ${isInbox && !email.read ? 'text-blue-700' : 'text-gray-700'}">
                    ${isInbox ? `${t.from}: ` : `${t.to}: `} ${senderOrRecipient}
                </span>
                <span class="text-xs text-gray-400">
                    ${new Date(email.timestamp.toMillis()).toLocaleTimeString(currentLang, {hour: '2-digit', minute:'2-digit'})}
                </span>
            `;

            const subjectText = document.createElement("div");
            subjectText.classList.add("truncate", "text-gray-500");
            subjectText.textContent = subject;

            content.appendChild(header);
            content.appendChild(subjectText);
            item.appendChild(content);

            item.addEventListener('click', () => {
                displayEmail(email);
            });

            emailList.appendChild(item);
        });
    }

    function displayEmail(email) {
        const t = translations[currentLang];
        
        // Hide list, show single email view
        emailList.classList.add("hidden");
        composeView.classList.add("hidden");
        emptyState.classList.add("hidden");
        emailView.classList.remove("hidden");

        const isInbox = email.folder === 'inbox';
        const senderOrRecipientLabel = isInbox ? t.from : t.to;
        const senderOrRecipient = isInbox ? email.sender : email.recipient;
        const date = new Date(email.timestamp.toMillis()).toLocaleString(currentLang);

        emailView.innerHTML = `
            <div class="flex flex-col h-full">
                <h3 class="text-2xl font-bold mb-2">${email.subject || t.noSubject}</h3>
                <div class="text-sm text-gray-600 mb-4 border-b pb-2">
                    <p class="${currentLang === 'he' ? 'rtl' : 'ltr'}">${senderOrRecipientLabel}: ${senderOrRecipient}</p>
                    <p class="text-xs">${date}</p>
                </div>
                <div class="flex-grow overflow-y-auto text-gray-800 whitespace-pre-wrap ${currentLang === 'he' ? 'rtl' : 'ltr'} p-4 bg-gray-50 rounded-lg shadow-inner">
                    ${email.body.replace(/\n/g, '<br>')}
                </div>
                <div class="mt-4 pt-4 border-t flex space-x-2 space-x-reverse">
                    <button id="replyBtn" class="bg-blue-500 text-white px-4 py-2 rounded-lg hover:bg-blue-600 transition font-semibold">
                        ${currentLang === 'he' ? 'השב' : 'Reply'}
                    </button>
                    <button id="deleteBtn" class="bg-red-500 text-white px-4 py-2 rounded-lg hover:bg-red-600 transition font-semibold">
                        <i class="fas fa-trash"></i>
                    </button>
                </div>
            </div>
        `;
        
        // Mark as read if it's in the inbox and unread
        if (isInbox && !email.read) {
            const emailsCollectionPath = `/artifacts/${appId}/public/data/emails`;
            updateDoc(doc(state.db, emailsCollectionPath, email.id), { read: true })
                .catch(e => console.error("Error marking email as read:", e));
        }

        document.getElementById('replyBtn').addEventListener('click', () => {
             newEmailButton.click();
             // Extract username from sender email for reply-to
             const senderUsername = email.sender.split('@')[0];
             composeTo.value = senderUsername;
             composeSubject.value = `${currentLang === 'he' ? 'השב:' : 'Re:'} ${email.subject || t.noSubject}`;
             composeBody.value = `\n\n--- ${senderOrRecipient} (${date}) ---\n${email.body}`;
        });
        document.getElementById('deleteBtn').addEventListener('click', () => {
             showConfirmation("האם אתה בטוח שברצונך למחוק אימייל זה?", () => {
                  // This is where you would move the email to the 'trash' folder or delete it
                  console.log("Move to Trash logic triggered for email:", email.id);
                  showFolder(state.currentFolder); // Go back to list view
             });
        });
    }

    // --- FIREBASE LISTENERS ---
    function listenToEmails() {
        // We query based on the canonical email address retrieved from the external API (state.emailAddress).
        if (!state.isAuthReady || !state.emailAddress) return;

        // Public collection for shared emails
        const emailsCollectionPath = `/artifacts/${appId}/public/data/emails`;
        const emailsRef = collection(state.db, emailsCollectionPath);
        
        // Listener for INBOX: Emails sent TO the user
        // We assume the security rules allow unauthenticated read if 'recipient' matches the requesting identity's canonical email.
        const inboxQuery = query(
            emailsRef, 
            where("recipient", "==", state.emailAddress) // Uses the server-derived email
        );
        
        // Listener for SENT: Emails sent FROM the user
        // We assume the security rules allow unauthenticated read if 'sender' matches the requesting identity's canonical email.
        const sentQuery = query(
            emailsRef, 
            where("sender", "==", state.emailAddress) // Uses the server-derived email
        );

        // INBOX Listener
        onSnapshot(inboxQuery, (snapshot) => {
            state.inboxEmails = [];
            snapshot.forEach(docSnap => {
                 state.inboxEmails.push({ id: docSnap.id, ...docSnap.data(), folder: "inbox" });
            });
            
            if (state.currentFolder === "inbox") {
                renderEmailList(state.inboxEmails);
            }
        }, error => console.error("Inbox listener error:", error));

        // SENT Listener
        onSnapshot(sentQuery, (snapshot) => {
             state.sentEmails = [];
            snapshot.forEach(docSnap => {
                 state.sentEmails.push({ id: docSnap.id, ...docSnap.data(), folder: "sent" });
            });

            if (state.currentFolder === "sent") {
                renderEmailList(state.sentEmails);
            }
        }, error => console.error("Sent listener error:", error));

    }

    function listenToDrafts() {
      // Drafts (private data) are stored using the server-derived UID (state.userId) in a private path.
      if (!state.isAuthReady || !state.userId) return;
      const t = translations[currentLang];
      
      // Private collection for drafts, using state.userId (Server ID)
      // We assume security rules allow unauthenticated reads/writes in this path if the ID matches.
      const draftsCollectionPath = `/artifacts/${appId}/users/${state.userId}/drafts`;
      
      const draftsRef = collection(state.db, draftsCollectionPath);

      onSnapshot(draftsRef, (snapshot) => {
        draftsList.innerHTML = "";
        const draftsCount = snapshot.docs.length;
        if (draftsCount > 0) {
             draftsHeader.classList.remove("hidden");
        } else {
             draftsHeader.classList.add("hidden");
        }

        snapshot.forEach(docSnap => {
          const draft = docSnap.data();
          const li = document.createElement("li");
          li.classList.add("flex", "justify-between", "items-center", "mb-1", "p-2", "hover:bg-gray-100", "rounded-lg");
          
          const span = document.createElement("span");
          span.textContent = draft.subject || t.noSubject;
          span.classList.add("cursor-pointer", "hover:text-blue-600", "truncate", "flex-1", "text-gray-700");
          span.addEventListener("click", () => {
            composeTo.value = draft.recipient ? draft.recipient.split('@')[0] : ""; // Display only username
            composeSubject.value = draft.subject || "";
            composeBody.value = draft.body || "";
            state.editingDraftId = docSnap.id;
            
            emailList.classList.add("hidden");
            emailView.classList.add("hidden");
            emptyState.classList.add("hidden");
            composeView.classList.remove("hidden");
            showFolder("drafts"); // Keep drafts highlighted
          });

          const delBtn = document.createElement("button");
          delBtn.innerHTML = '<i class="fas fa-trash-alt text-red-500 text-xs hover:scale-110 transition"></i>';
          delBtn.classList.add("text-red-500", "mr-2", "p-1");
          delBtn.addEventListener("click", async (e) => {
            e.stopPropagation();
            showConfirmation(t.deleteDraftConfirm, async () => {
              await deleteDoc(doc(state.db, draftsCollectionPath, docSnap.id));
            });
          });

          li.appendChild(span);
          li.appendChild(delBtn);
          draftsList.appendChild(li);
        });

        if (state.currentFolder === 'drafts') {
            showFolder('drafts'); // Re-render empty state if applicable
        }
      }, error => console.error("Drafts listener error:", error));
    }

    // --- COMPOSE / SEND / SAVE DRAFT LOGIC ---

    newEmailButton.addEventListener("click", () => {
      state.editingDraftId = null;
      composeTo.value = "";
      composeSubject.value = "";
      composeBody.value = "";
      
      emailList.classList.add("hidden");
      emailView.classList.add("hidden");
      emptyState.classList.add("hidden");
      composeView.classList.remove("hidden");
    });

    cancelButton.addEventListener("click", () => {
      composeView.classList.add("hidden");
      showFolder(state.currentFolder);
      state.editingDraftId = null;
    });

    sendButton.addEventListener("click", async () => {
      if (!state.emailAddress) return console.error("Sender email not set. Cannot send.");
      const recipientUsername = composeTo.value.trim();
      if (!recipientUsername) {
          console.error("Recipient username is required.");
          return;
      }
      
      // Enforce the internal email format: username@family.local
      const enforcedRecipient = `${recipientUsername}@family.local`;

      // Public collection for shared emails
      const emailsCollectionPath = `/artifacts/${appId}/public/data/emails`;

      try {
        const emailData = {
          sender: state.emailAddress, // Sender is the server-derived email
          recipient: enforcedRecipient, // Recipient is the internal server format
          subject: composeSubject.value.trim(),
          body: composeBody.value.trim(),
          timestamp: Timestamp.now(),
          read: false,
        };
        
        await addDoc(collection(db, emailsCollectionPath), emailData);

        if (state.editingDraftId) {
             // Private path for deletion
             const draftsCollectionPath = `/artifacts/${appId}/users/${state.userId}/drafts`;
             await deleteDoc(doc(state.db, draftsCollectionPath, state.editingDraftId));
        }

        composeTo.value = "";
        composeSubject.value = "";
        composeBody.value = "";
        composeView.classList.add("hidden");
        showFolder("sent");

      } catch (err) {
        console.error("Send error", err);
      }
    });

    saveDraftButton.addEventListener("click", async () => {
      if (!state.userId) return console.error("User ID not available for drafts.");
      
      // Private collection for drafts, using state.userId (Server ID)
      const draftsCollectionPath = `/artifacts/${appId}/users/${state.userId}/drafts`;

      try {
        const recipientUsername = composeTo.value.trim();
        // Save the full internal email address format, even in draft
        const enforcedRecipient = recipientUsername ? `${recipientUsername}@family.local` : '';

        const draftData = {
            sender: state.emailAddress,
            recipient: enforcedRecipient,
            subject: composeSubject.value.trim(),
            body: composeBody.value.trim(),
            timestamp: Timestamp.now(),
        };
        
        if (state.editingDraftId) {
          await setDoc(doc(state.db, draftsCollectionPath, state.editingDraftId), draftData);
        } else {
          await addDoc(collection(state.db, draftsCollectionPath), draftData);
        }
        
        composeView.classList.add("hidden");
        showFolder("drafts");
        state.editingDraftId = null;
      } catch (err) {
        console.error("Draft save error", err);
      }
    });
    
    // --- TRANSLATE (DUMMY) LOGIC ---

    async function translateText(text, targetLang) {
      if (!text.trim()) return text;
      // Dummy response for translation
      await new Promise(r => setTimeout(r, 500)); // Simulate API delay
      return `[${targetLang.toUpperCase()} Translated] ${text}`;
    }

    translateButton.addEventListener("click", async () => {
      const targetLang = currentLang === "he" ? "en" : "he";
      const t = translations[currentLang];
      
      translateButton.textContent = currentLang === "he" ? "מתרגם..." : "Translating...";
      translateButton.disabled = true;

      composeSubject.value = await translateText(composeSubject.value, targetLang);
      composeBody.value = await translateText(composeBody.value, targetLang);
      
      translateButton.textContent = t.translate;
      translateButton.disabled = false;
    });


  </script>
</body>
</html>
